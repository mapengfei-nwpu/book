shared指针

拥有一个自动运作的系统，能应用到所有资源并具备可预测时序。

书上对自动运作的注释：类似垃圾回收。就是销毁了一个对象后，这个对象所占用的内存会被系统回收。书上对可预测时序的注释：类似析构函数。就是程序员知道资源是什么时候释放的，什么顺序释放的。这两个特点使得用户不用操心对象的生存期，但又如析构函数一样，该对象的析构函数时序是确定的。

shared指针是普通指针的两倍大小，包含一个指向资源的指针和一个指向控制块的指针。

移动构造函数可以移动shared指针，比赋值操作少一个递增引用计数操作。

shared指针的自定义析构器和unique的不太一样，shared指针的自定义析构器并不存储在指针对象中，而是存储在控制块中，因此，即使两个shared指针包含的析构类型不一样，shared指针的类型也是相同的，也就是说，自定义析构器的类型不会影响shared指针的类别。

make_shared总是创建一个控制块

从具备转悠所有权的指针出发构造一个shared指针时会创建一个控制块。专属指针是指unique指针或auto指针。

从裸指针创造一个shared指针，一般要创建控制块。创建了shared指针以后就禁止再使用原来的裸指针了，因为你不知道什么时候资源被shared指针给释放了，而且也不能使用裸指针创建多个shared指针。因此，尽量不要使用裸指针创建shared指针。我们应该直接传递new运算符的结果：

```c++
std::shared_ptr<Widget> spw1(new Widget, loggingDel);
```

如果要创建指向同一块内存的shared指针，最好从当前的shared指针创建一个新的指针。

假设我们的程序使用shared指针来托管对象，并且有个数据结构（vector）用来追踪被处理的对象。又假设这个对象有个成员函数用做这种处理。这一段我没看懂，总之不要针对同一个对象创建多个控制块，一个对象的this指针也是裸指针，不要将它用来创建shared指针，而是使用 `shared_from_this()` 函数。

因使用shared指针产生的额外开销并不大。有时候权衡一下到底使用unique指针还是shared指针，很多时候使用unique指针就能够胜任了。因为unique开销更小，而且可以转换成shared指针，但是shared指针不能转换成unique指针。

不要让shared指针指向一个数组，可以使用shared指针的vector，array等数据结构。





